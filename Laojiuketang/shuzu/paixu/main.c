//
//  main.c
//  paixu
//
//  Created by 张兴超 on 2021/8/13.
//
//16 25 9 90 23
//降序排列-从大到小
//冒泡排序基础原理：遍历和交换
//第一轮循环：哪个数字小于后面的数字，那么就交换。
//0轮：1次 25 16 9 90 23   2次 25 16 9 90 23   3次 25 16 90 9 23   4次 25 16 90 23 9
//1轮：1次 25 90 16 23 9   2次 25 90 23 16 9   3次 25 90 23 16 9
//2轮：1次 90 25 23 16 9   2次 90 25 23 16 9
//3轮：1次 90 25 23 16 9
//最小的数字就冒到了最后
//********************************************************************************
//注意：1、需要比较多轮。轮数：（数组长度-1）轮
//     2、每一轮比较的次数比上一轮 -1 次 。 次数：（数组长度-1）- 当前的轮数
//     外层循环控制轮数，内层循环控制次数。
//********************************************************************************

#include <stdio.h>
#define N 5  //宏定义

/*
int main(int argc, const char * argv[])
{
    int i,j;
    int tmp;
    int nums[N]={16,25,9,90,23};
    for(i=0;i<N-1;i++)             //要进行的轮数i= N-1轮
    {
        for (j=0;j<N-i-1; j++)    //要进行的次数 j= N-i-1次
        {
            if (nums[j]<nums[j+1]) {  //  改成大于号>就变成逆序
                tmp=nums[j];
                nums[j]=nums[j+1];
                nums[j+1]=tmp;
            }
        }
    }
    printf("排序后的结果是：\n");
    for(i=0;i<N;i++)            //循环打印输出
    {
        printf("%d  \n",nums[i]);
    }
    return 0;
}

//总结错误点：1、没有想到外层循环和内层循环算法的使用。 2、输出的时候应使用循环来进行数组的输出
//思考：在数组已经有序的情况下，逆序可以重复采用冒泡排序方式直接输出
//如果数组在初始无序的情况下，如何找规律使得数组逆序输出？
//如：12 34 23 67 9
//    i         N-i-1
//逆序：第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换。
 即：
 for（i=0；i<N；i++）
{
    tmp=nums[i];
    nums[i]=nums[N-i-1];
    nums[N-i-1]=tmp;
}
*/
 


  
//删除算法：******************************************************************************************************
/* 删除的逻辑，例如：12 34 23 67 9  删除第二个元素后：12 34 67 9 9
 即：1 查找要删除的数字的下标（上面这是删除的第二个元素）
    2 从下标开始，后面一个覆盖前面一个数字
    3 数组的总长度要-1
 */
int main()
{
    int count=5;            //表示数组元素的个数
    double powers[]={42322,45771,40907,41234,40767};
    int deletepower;        //用户要删除的战力值
    int deleteindex = -1;   //用户要删除的战力值的下标，给一个不可能的初值
    int i;                  //循环变量
    double insertpower;     //新插入的战力值
    printf("请输入要删除的变量：");
    scanf("%d",&deletepower);
    for (i=0; i<count; i++)
    {
        if (deletepower==powers[i])
        {
            deleteindex=i;    //记录下当前的下标
            break;            //找到了要删除的战力值，直接跳出循环，提升效率。
        }
    }
    //根据判断（是否找到），执行后续操作，
    if(-1==deleteindex)
    {
        printf("很遗憾，没有找到要删除的战力值，删除失败！\n");
    }
    else{
        //从下标开始，后面一个覆盖前面一个数字
        for(i=deleteindex;i<count-1;i++)         //i=deleteindex
        {
            powers[i]=powers[i+1];
        }
        count--;
    }
    for (i=0; i<count; i++)                    //删除一个，记得数组长度-1
    {
        printf("%lf \n",powers[i]);
    }
    //删除之后进行插入
    printf("请输入新战力值：");
    scanf("%lf",&insertpower);
    powers[count]=insertpower;                  //插入操作完成后，记得数组总长度+1 注意理解
    count++;
    printf("插入后的结果为：");
    for(i=0;i<count;i++)
    {
        printf("%.2lf  \n",powers[i]);
    }
    //如果想让战力值有序，再用冒泡法。
}
